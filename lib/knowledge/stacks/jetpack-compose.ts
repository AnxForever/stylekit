// Knowledge Base - Jetpack Compose Guidelines
// Data converted from stacks/jetpack-compose.csv

import type { StackGuideline } from "./types";

export const jetpackComposeGuidelines: StackGuideline[] = [
  {
    category: "Composables",
    guideline: "Follow composable function conventions",
    description: "Composable functions should be named with PascalCase and annotated with @Composable",
    do: "Use PascalCase for composables that emit UI, camelCase for composables that return values",
    dont: "Mix naming conventions or forget @Composable annotation",
    codeGood: "@Composable\nfun UserProfile(user: User) {\n  Column { Text(user.name); Text(user.email) }\n}",
    codeBad: "fun userProfile(user: User) { /* Missing @Composable, wrong naming */ }",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/mental-model",
  },
  {
    category: "Composables",
    guideline: "Keep composables small and focused",
    description: "Extract sub-sections of UI into separate composable functions for readability, reuse, and testability",
    do: "Break large composables into smaller, single-responsibility composables",
    dont: "Build entire screens in one composable function",
    codeGood: "@Composable fun ProfileScreen() {\n  Column { ProfileHeader(user); ProfileStats(stats); ProfileActions(onEdit, onShare) }\n}",
    codeBad: "@Composable fun ProfileScreen() { Column { /* 300 lines of nested composables */ } }",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/mental-model#recomposition",
  },
  {
    category: "State",
    guideline: "Use remember with mutableStateOf for local state",
    description: "remember preserves state across recompositions. mutableStateOf creates observable state that triggers recomposition",
    do: "Use remember { mutableStateOf(initialValue) } for local UI state",
    dont: "Use plain variables that reset on recomposition",
    codeGood: "var count by remember { mutableStateOf(0) }\nButton(onClick = { count++ }) { Text(\"Count: $count\") }",
    codeBad: "var count = 0 // Resets to 0 on every recomposition\nButton(onClick = { count++ }) { Text(\"Count: $count\") }",
    severity: "Critical",
    docsUrl: "https://developer.android.com/develop/ui/compose/state",
  },
  {
    category: "State",
    guideline: "Hoist state to the appropriate level",
    description: "Move state up to the lowest common ancestor that needs it. Pass state down and events up",
    do: "Create stateless composables that receive state and emit events",
    dont: "Keep state in leaf composables when parent needs it",
    codeGood: "@Composable fun Counter(count: Int, onIncrement: () -> Unit) {\n  Button(onClick = onIncrement) { Text(\"Count: $count\") }\n}",
    codeBad: "@Composable fun Counter() {\n  var count by remember { mutableStateOf(0) } // Parent cannot observe this\n}",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/state#state-hoisting",
  },
  {
    category: "SideEffects",
    guideline: "Use LaunchedEffect for coroutines",
    description: "LaunchedEffect launches a coroutine scoped to the composable lifecycle. It cancels and relaunches when keys change",
    do: "Use LaunchedEffect for one-time or key-dependent async operations",
    dont: "Launch coroutines in event handlers that need lifecycle awareness",
    codeGood: "LaunchedEffect(userId) {\n  val user = repository.getUser(userId)\n  userState = user\n}",
    codeBad: "val scope = rememberCoroutineScope()\nonClick { scope.launch { /* Long-running work not tied to lifecycle */ } }",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/side-effects#launchedeffect",
  },
  {
    category: "SideEffects",
    guideline: "Use DisposableEffect for cleanup",
    description: "DisposableEffect provides an onDispose block for cleanup when the effect leaves the composition or keys change",
    do: "Use DisposableEffect for listeners, observers, and resources that need cleanup",
    dont: "Register listeners without cleanup logic",
    codeGood: "DisposableEffect(lifecycle) {\n  val observer = LifecycleEventObserver { ... }\n  lifecycle.addObserver(observer)\n  onDispose { lifecycle.removeObserver(observer) }\n}",
    codeBad: "LaunchedEffect(Unit) { lifecycle.addObserver(observer) } // Never removed",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/side-effects#disposableeffect",
  },
  {
    category: "Layout",
    guideline: "Use Column, Row, and Box for layout",
    description: "Compose provides Column (vertical), Row (horizontal), and Box (overlap) as fundamental layout composables",
    do: "Compose layouts with Column, Row, Box and their alignment/arrangement parameters",
    dont: "Use ConstraintLayout for simple linear layouts",
    codeGood: "Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n  Icon(Icons.Default.Person, null)\n  Text(user.name)\n}",
    codeBad: "ConstraintLayout { /* Complex constraints for a simple horizontal row */ }",
    severity: "Medium",
    docsUrl: "https://developer.android.com/develop/ui/compose/layouts/basics",
  },
  {
    category: "Navigation",
    guideline: "Use Navigation Compose for navigation",
    description: "Navigation Compose provides type-safe navigation with NavHost, composable destinations, and deep linking",
    do: "Define routes with NavHost and navigate with NavController",
    dont: "Manage navigation state manually with conditional composables",
    codeGood: "NavHost(navController, startDestination = \"home\") {\n  composable(\"home\") { HomeScreen(onNavigate = { navController.navigate(\"detail/$id\") }) }\n  composable(\"detail/{id}\") { DetailScreen(it.arguments?.getString(\"id\")) }\n}",
    codeBad: "var currentScreen by remember { mutableStateOf(\"home\") }\nwhen (currentScreen) { \"home\" -> HomeScreen(); \"detail\" -> DetailScreen() }",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/navigation",
  },
  {
    category: "Lists",
    guideline: "Use LazyColumn and LazyRow for lists",
    description: "LazyColumn and LazyRow only compose and lay out visible items, essential for performance with large data sets",
    do: "Use LazyColumn with items() or itemsIndexed() for scrollable lists",
    dont: "Use Column with forEach for lists that may grow",
    codeGood: "LazyColumn {\n  items(users, key = { it.id }) { user -> UserRow(user) }\n}",
    codeBad: "Column(Modifier.verticalScroll(rememberScrollState())) {\n  users.forEach { user -> UserRow(user) } // All composed at once\n}",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/lists",
  },
  {
    category: "Theming",
    guideline: "Use MaterialTheme for consistent styling",
    description: "MaterialTheme provides colors, typography, and shapes that propagate through the composition tree",
    do: "Access theme values via MaterialTheme.colorScheme, typography, and shapes",
    dont: "Hardcode colors and text styles in composables",
    codeGood: "Text(\"Title\", style = MaterialTheme.typography.headlineMedium, color = MaterialTheme.colorScheme.primary)",
    codeBad: "Text(\"Title\", fontSize = 24.sp, color = Color(0xFF1976D2)) // Hardcoded values",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/designsystems/material3",
  },
  {
    category: "Animation",
    guideline: "Use animate*AsState for simple animations",
    description: "animate*AsState APIs provide simple state-driven animations that automatically animate between values",
    do: "Use animateDpAsState, animateColorAsState, etc. for property animations",
    dont: "Use Animatable directly for simple value transitions",
    codeGood: "val size by animateDpAsState(targetValue = if (expanded) 200.dp else 100.dp, animationSpec = spring())\nBox(Modifier.size(size))",
    codeBad: "val animatable = remember { Animatable(100f) }\nLaunchedEffect(expanded) { animatable.animateTo(if (expanded) 200f else 100f) }",
    severity: "Medium",
    docsUrl: "https://developer.android.com/develop/ui/compose/animation/value-based",
  },
  {
    category: "Performance",
    guideline: "Use derivedStateOf for computed values",
    description: "derivedStateOf prevents unnecessary recompositions by only updating when the derived value actually changes",
    do: "Wrap expensive computations that read state in remember + derivedStateOf",
    dont: "Compute derived values directly in composition that trigger frequent recomposition",
    codeGood: "val sortedItems by remember { derivedStateOf { items.sortedBy { it.name } } }",
    codeBad: "val sortedItems = items.sortedBy { it.name } // Recomputed on every recomposition",
    severity: "Medium",
    docsUrl: "https://developer.android.com/develop/ui/compose/side-effects#derivedstateof",
  },
  {
    category: "Performance",
    guideline: "Provide stable keys for lazy lists",
    description: "Providing stable keys to lazy list items helps Compose identify and reuse items efficiently",
    do: "Use the key parameter in items() with a unique stable identifier",
    dont: "Rely on positional index as the implicit key",
    codeGood: "LazyColumn { items(users, key = { it.id }) { user -> UserRow(user) } }",
    codeBad: "LazyColumn { items(users) { user -> UserRow(user) } } // Uses index, breaks on reorder",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/lists#item-keys",
  },
  {
    category: "Accessibility",
    guideline: "Add content descriptions and semantics",
    description: "Use Modifier.semantics and contentDescription to make UI accessible to TalkBack and other assistive services",
    do: "Add contentDescription to icons and images, use semantics for custom components",
    dont: "Leave decorative icons and interactive elements without descriptions",
    codeGood: "Icon(Icons.Default.Favorite, contentDescription = \"Add to favorites\")\nBox(Modifier.semantics { role = Role.Button; stateDescription = if (selected) \"Selected\" else \"Not selected\" })",
    codeBad: "Icon(Icons.Default.Favorite, contentDescription = null) // Invisible to TalkBack\nBox(Modifier.clickable { }) // No semantic info",
    severity: "High",
    docsUrl: "https://developer.android.com/develop/ui/compose/accessibility",
  },
];

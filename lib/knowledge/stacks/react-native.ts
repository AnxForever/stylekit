// Knowledge Base - React Native Guidelines
// Data converted from stacks/react-native.csv

import type { StackGuideline } from "./types";

export const reactNativeGuidelines: StackGuideline[] = [
  {
    category: "Components",
    guideline: "Use functional components with hooks",
    description: "Functional components with hooks are the standard pattern for React Native development",
    do: "Use function components with useState, useEffect, etc.",
    dont: "Use class components for new code",
    codeGood: "function Profile({ userId }: Props) {\n  const [user, setUser] = useState<User | null>(null);\n  return <View><Text>{user?.name}</Text></View>;\n}",
    codeBad: "class Profile extends Component { render() { return <View>...</View>; } }",
    severity: "Medium",
    docsUrl: "https://reactnative.dev/docs/intro-react",
  },
  {
    category: "Styling",
    guideline: "Use StyleSheet.create for styles",
    description: "StyleSheet.create validates styles at creation time and enables optimization through style ID references",
    do: "Define styles with StyleSheet.create outside the component",
    dont: "Use inline style objects that create new references each render",
    codeGood: "const styles = StyleSheet.create({ container: { flex: 1, padding: 16 }, title: { fontSize: 24, fontWeight: 'bold' } });",
    codeBad: "<View style={{ flex: 1, padding: 16 }}> // New object every render",
    severity: "High",
    docsUrl: "https://reactnative.dev/docs/stylesheet",
  },
  {
    category: "Navigation",
    guideline: "Use React Navigation for routing",
    description: "React Navigation is the standard navigation library with stack, tab, drawer, and native stack navigators",
    do: "Use @react-navigation/native with appropriate navigator types",
    dont: "Build custom navigation state management",
    codeGood: "<NavigationContainer>\n  <Stack.Navigator>\n    <Stack.Screen name=\"Home\" component={HomeScreen} />\n    <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n  </Stack.Navigator>\n</NavigationContainer>",
    codeBad: "const [currentScreen, setCurrentScreen] = useState('Home'); // Custom navigation state",
    severity: "High",
    docsUrl: "https://reactnavigation.org/docs/getting-started",
  },
  {
    category: "Lists",
    guideline: "Use FlatList for long lists",
    description: "FlatList virtualizes list items, only rendering what is visible on screen for better performance",
    do: "Use FlatList with keyExtractor and renderItem",
    dont: "Use ScrollView with map for long lists",
    codeGood: "<FlatList\n  data={items}\n  keyExtractor={(item) => item.id}\n  renderItem={({ item }) => <ItemCard item={item} />}\n/>",
    codeBad: "<ScrollView>{items.map(item => <ItemCard key={item.id} item={item} />)}</ScrollView> // All rendered at once",
    severity: "High",
    docsUrl: "https://reactnative.dev/docs/flatlist",
  },
  {
    category: "Lists",
    guideline: "Optimize FlatList with getItemLayout",
    description: "When items have a fixed height, provide getItemLayout to skip measurement and enable instant scroll-to-index",
    do: "Provide getItemLayout when list items have uniform height",
    dont: "Leave FlatList to measure every item dynamically when heights are known",
    codeGood: "getItemLayout={(data, index) => ({ length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index })}",
    codeBad: "// No getItemLayout with 1000+ fixed-height items, causing layout thrashing",
    severity: "Medium",
    docsUrl: "https://reactnative.dev/docs/flatlist#getitemlayout",
  },
  {
    category: "Platform",
    guideline: "Handle platform differences explicitly",
    description: "Use Platform.OS or Platform.select for platform-specific logic and styles",
    do: "Use Platform.OS, Platform.select, or .ios.tsx/.android.tsx file extensions",
    dont: "Assume identical behavior across iOS and Android",
    codeGood: "const styles = StyleSheet.create({ shadow: Platform.select({\n  ios: { shadowColor: '#000', shadowOffset: { width: 0, height: 2 } },\n  android: { elevation: 4 }\n}) });",
    codeBad: "{ shadowColor: '#000', elevation: 4 } // Mixed platform shadow props",
    severity: "Medium",
    docsUrl: "https://reactnative.dev/docs/platform-specific-code",
  },
  {
    category: "Touch",
    guideline: "Use Pressable for touch interactions",
    description: "Pressable is the recommended component for handling press interactions with hover, focus, and press states",
    do: "Use Pressable with style callback for press state feedback",
    dont: "Use TouchableOpacity or TouchableHighlight for new code",
    codeGood: "<Pressable onPress={handlePress} style={({ pressed }) => [styles.button, pressed && styles.buttonPressed]}>\n  <Text>Press Me</Text>\n</Pressable>",
    codeBad: "<TouchableOpacity onPress={handlePress}><Text>Press Me</Text></TouchableOpacity>",
    severity: "Medium",
    docsUrl: "https://reactnative.dev/docs/pressable",
  },
  {
    category: "DataFetching",
    guideline: "Use React Query or SWR for server state",
    description: "React Query (TanStack Query) handles caching, refetching, and loading/error states for server data",
    do: "Use useQuery and useMutation for API data",
    dont: "Manage API state manually with useState and useEffect",
    codeGood: "const { data, isLoading, error } = useQuery({ queryKey: ['users'], queryFn: fetchUsers });",
    codeBad: "const [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nuseEffect(() => { fetch(...).then(setData).finally(() => setLoading(false)); }, []);",
    severity: "High",
    docsUrl: "https://tanstack.com/query/latest/docs/framework/react/react-native",
  },
  {
    category: "State",
    guideline: "Use lightweight state management",
    description: "Use Zustand or Jotai for client state instead of heavy solutions like Redux for most apps",
    do: "Use Zustand for global client state with simple API",
    dont: "Set up Redux with actions/reducers/middleware for simple state",
    codeGood: "const useStore = create<State>((set) => ({ count: 0, increment: () => set((s) => ({ count: s.count + 1 })) }));",
    codeBad: "const store = createStore(rootReducer, applyMiddleware(thunk)); // Boilerplate-heavy",
    severity: "Medium",
    docsUrl: "https://github.com/pmndrs/zustand",
  },
  {
    category: "Images",
    guideline: "Use optimized image libraries",
    description: "Use react-native-fast-image for performant image loading with caching and priority support",
    do: "Use FastImage for network images with caching",
    dont: "Use the built-in Image component for network images in lists",
    codeGood: "<FastImage source={{ uri: imageUrl, priority: FastImage.priority.normal }} style={styles.image} resizeMode={FastImage.resizeMode.cover} />",
    codeBad: "<Image source={{ uri: imageUrl }} /> // No caching, flickers in lists",
    severity: "Medium",
    docsUrl: "https://github.com/DylanVann/react-native-fast-image",
  },
  {
    category: "Performance",
    guideline: "Memoize components and callbacks",
    description: "Use React.memo, useMemo, and useCallback to prevent unnecessary re-renders in list items and child components",
    do: "Memo list item components and callbacks passed to children",
    dont: "Create new functions and objects inline in render for frequently updating components",
    codeGood: "const ListItem = memo(function ListItem({ item, onPress }: Props) { ... });\nconst handlePress = useCallback((id: string) => { ... }, []);",
    codeBad: "renderItem={({ item }) => <View onPress={() => onPress(item.id)}>...</View>} // New function each render",
    severity: "High",
    docsUrl: "https://reactnative.dev/docs/optimizing-flatlist-configuration",
  },
  {
    category: "Performance",
    guideline: "Avoid unnecessary re-renders with InteractionManager",
    description: "Defer expensive operations until after animations complete using InteractionManager",
    do: "Use InteractionManager.runAfterInteractions for heavy work after navigation",
    dont: "Run expensive setup during screen transitions",
    codeGood: "useEffect(() => {\n  InteractionManager.runAfterInteractions(() => { loadHeavyData(); });\n}, []);",
    codeBad: "useEffect(() => { loadHeavyData(); }, []); // Jank during navigation transition",
    severity: "Medium",
    docsUrl: "https://reactnative.dev/docs/interactionmanager",
  },
  {
    category: "Accessibility",
    guideline: "Use accessibility props on all interactive elements",
    description: "Provide accessibilityLabel, accessibilityRole, and accessibilityHint for screen reader support",
    do: "Add accessibility props to Pressable, Image, and custom interactive components",
    dont: "Leave interactive elements without accessibility labels",
    codeGood: "<Pressable accessibilityRole=\"button\" accessibilityLabel=\"Add to cart\" accessibilityHint=\"Adds this item to your shopping cart\" onPress={addToCart}>",
    codeBad: "<Pressable onPress={addToCart}><Image source={cartIcon} /></Pressable> // No a11y info",
    severity: "High",
    docsUrl: "https://reactnative.dev/docs/accessibility",
  },
  {
    category: "Accessibility",
    guideline: "Support dynamic text sizes",
    description: "Allow system font size scaling and test with large text settings",
    do: "Use relative font sizes and test with accessibility font scaling enabled",
    dont: "Disable font scaling or use fixed pixel layouts that break with large text",
    codeGood: "<Text allowFontScaling={true} maxFontSizeMultiplier={1.5} style={styles.body}>Content</Text>",
    codeBad: "<Text allowFontScaling={false} style={{ fontSize: 12 }}>Content</Text> // Ignores user preference",
    severity: "Medium",
    docsUrl: "https://reactnative.dev/docs/text#allowfontscaling",
  },
];

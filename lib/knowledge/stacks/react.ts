// Knowledge Base - React Guidelines
// Data converted from stacks/react.csv

import type { StackGuideline } from "./types";

export const reactStackGuidelines: StackGuideline[] = [
  {
    category: "State",
    guideline: "Use useState for local state",
    description: "Simple component state should use useState hook",
    do: "useState for form inputs toggles counters",
    dont: "Class components this.state",
    codeGood: "const [count, setCount] = useState(0)",
    codeBad: "this.state = { count: 0 }",
    severity: "Medium",
    docsUrl: "https://react.dev/reference/react/useState",
  },
  {
    category: "State",
    guideline: "Batch state updates",
    description: "React 18+ automatically batches state updates",
    do: "Multiple setState calls are batched",
    dont: "Manual batching workarounds",
    codeGood: "setA(1); setB(2); // one render",
    codeBad: "ReactDOM.flushSync() unnecessarily",
    severity: "Low",
    docsUrl: "https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching",
  },
  {
    category: "Effects",
    guideline: "useEffect for synchronization",
    description: "Use useEffect to sync with external systems, not for derived state",
    do: "useEffect for subscriptions, DOM updates",
    dont: "useEffect to compute derived values",
    codeGood: "useEffect(() => { const sub = api.subscribe(); return () => sub.unsubscribe(); }, [])",
    codeBad: "useEffect(() => { setFullName(first + ' ' + last); }, [first, last])",
    severity: "High",
    docsUrl: "https://react.dev/learn/synchronizing-with-effects",
  },
  {
    category: "Effects",
    guideline: "Cleanup side effects",
    description: "Return cleanup function from useEffect for subscriptions/timers",
    do: "Return cleanup function",
    dont: "Leave subscriptions without cleanup",
    codeGood: "useEffect(() => { const id = setInterval(...); return () => clearInterval(id); }, [])",
    codeBad: "useEffect(() => { setInterval(...); }, [])",
    severity: "Critical",
    docsUrl: "https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development",
  },
  {
    category: "Rendering",
    guideline: "Keep render pure",
    description: "Render should be a pure function of props and state",
    do: "Calculate during render, no side effects",
    dont: "Mutate state or call APIs during render",
    codeGood: "const fullName = firstName + ' ' + lastName; return <span>{fullName}</span>",
    codeBad: "fetch() or localStorage.setItem() in render",
    severity: "Critical",
    docsUrl: "https://react.dev/learn/keeping-components-pure",
  },
  {
    category: "Rendering",
    guideline: "Use keys for lists",
    description: "Provide stable unique keys for list items",
    do: "Use unique IDs as keys",
    dont: "Use array index as key for dynamic lists",
    codeGood: "{items.map(item => <Item key={item.id} {...item} />)}",
    codeBad: "{items.map((item, index) => <Item key={index} {...item} />)}",
    severity: "High",
    docsUrl: "https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key",
  },
  {
    category: "Components",
    guideline: "Use function components",
    description: "Function components with hooks are the modern pattern",
    do: "function Component() or const Component = () =>",
    dont: "Class components for new code",
    codeGood: "function Button({ onClick, children }) { return <button onClick={onClick}>{children}</button> }",
    codeBad: "class Button extends Component { render() { } }",
    severity: "Medium",
    docsUrl: "https://react.dev/learn/your-first-component",
  },
  {
    category: "Components",
    guideline: "Composition over prop drilling",
    description: "Pass components as children or props instead of drilling data",
    do: "Use children prop and composition",
    dont: "Pass data through many intermediate components",
    codeGood: "<Layout sidebar={<Sidebar user={user} />}><Content /></Layout>",
    codeBad: "<A user={user}><B user={user}><C user={user} /></B></A>",
    severity: "Medium",
    docsUrl: "https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children",
  },
  {
    category: "Props",
    guideline: "Destructure props",
    description: "Destructure props in function signature for clarity",
    do: "function Button({ variant, size, children })",
    dont: "Use props.variant throughout",
    codeGood: "function Alert({ type, message }) { return <div className={type}>{message}</div> }",
    codeBad: "function Alert(props) { return <div className={props.type}>{props.message}</div> }",
    severity: "Low",
    docsUrl: "https://react.dev/learn/passing-props-to-a-component",
  },
  {
    category: "Props",
    guideline: "Use defaultProps or default parameters",
    description: "Provide sensible defaults for optional props",
    do: "function Button({ variant = 'primary' })",
    dont: "Check for undefined throughout component",
    codeGood: "function Button({ size = 'md', variant = 'primary' }) { }",
    codeBad: "function Button({ size, variant }) { const s = size || 'md'; }",
    severity: "Low",
    docsUrl: "https://react.dev/learn/passing-props-to-a-component#specifying-a-default-value-for-a-prop",
  },
  {
    category: "Events",
    guideline: "Name handlers consistently",
    description: "Use handle prefix for event handlers, on prefix for props",
    do: "handleClick for handler, onClick for prop",
    dont: "Inconsistent naming like clickHandler or click",
    codeGood: "const handleSubmit = () => {}; <Form onSubmit={handleSubmit} />",
    codeBad: "const submitForm = () => {}; <Form submit={submitForm} />",
    severity: "Low",
    docsUrl: "https://react.dev/learn/responding-to-events",
  },
  {
    category: "Forms",
    guideline: "Controlled inputs",
    description: "Control form inputs with React state",
    do: "value={state} onChange={setState}",
    dont: "Uncontrolled inputs for complex forms",
    codeGood: "<input value={name} onChange={e => setName(e.target.value)} />",
    codeBad: "<input defaultValue={name} ref={inputRef} />",
    severity: "Medium",
    docsUrl: "https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components",
  },
  {
    category: "Hooks",
    guideline: "Follow Rules of Hooks",
    description: "Only call hooks at top level, only in function components",
    do: "Call hooks at component top level",
    dont: "Hooks inside conditions or loops",
    codeGood: "function Component() { const [state, setState] = useState(); if (condition) { /*...*/ } }",
    codeBad: "function Component() { if (condition) { const [state, setState] = useState(); } }",
    severity: "Critical",
    docsUrl: "https://react.dev/reference/rules/rules-of-hooks",
  },
  {
    category: "Hooks",
    guideline: "Extract custom hooks",
    description: "Extract reusable stateful logic into custom hooks",
    do: "Create useFetch, useLocalStorage, etc.",
    dont: "Duplicate hook logic across components",
    codeGood: "function useFetch(url) { const [data, setData] = useState(); useEffect(...); return data; }",
    codeBad: "Copy-paste useState + useEffect in every component",
    severity: "Medium",
    docsUrl: "https://react.dev/learn/reusing-logic-with-custom-hooks",
  },
  {
    category: "Context",
    guideline: "Use Context for global state",
    description: "Context for widely-needed values like theme, user, locale",
    do: "createContext + Provider for global state",
    dont: "Context for frequently changing values",
    codeGood: "const ThemeContext = createContext(); <ThemeContext.Provider value={theme}>",
    codeBad: "Passing position coordinates through Context (updates too often)",
    severity: "Medium",
    docsUrl: "https://react.dev/learn/passing-data-deeply-with-context",
  },
  {
    category: "Performance",
    guideline: "Memo expensive components",
    description: "Use React.memo for components with expensive renders",
    do: "memo() for pure components that render often",
    dont: "memo() everything",
    codeGood: "const ExpensiveList = memo(function ExpensiveList({ items }) { })",
    codeBad: "const SimpleButton = memo(function SimpleButton() { })",
    severity: "Medium",
    docsUrl: "https://react.dev/reference/react/memo",
  },
  {
    category: "Performance",
    guideline: "useMemo for expensive calculations",
    description: "Memoize expensive computations",
    do: "useMemo for filtering/sorting large arrays",
    dont: "useMemo for simple operations",
    codeGood: "const sorted = useMemo(() => items.sort((a, b) => a.name.localeCompare(b.name)), [items])",
    codeBad: "const doubled = useMemo(() => count * 2, [count])",
    severity: "Medium",
    docsUrl: "https://react.dev/reference/react/useMemo",
  },
  {
    category: "Performance",
    guideline: "useCallback for handler props",
    description: "Memoize callbacks passed to memoized children",
    do: "useCallback when passing to memo'd components",
    dont: "useCallback for every function",
    codeGood: "const handleClick = useCallback(() => setCount(c => c + 1), [])",
    codeBad: "Every onClick wrapped in useCallback",
    severity: "Medium",
    docsUrl: "https://react.dev/reference/react/useCallback",
  },
  {
    category: "ErrorHandling",
    guideline: "Use Error Boundaries",
    description: "Catch rendering errors with Error Boundary components",
    do: "Wrap sections with Error Boundaries",
    dont: "Let errors crash entire app",
    codeGood: "<ErrorBoundary fallback={<Error />}><App /></ErrorBoundary>",
    codeBad: "No error boundaries (one error crashes app)",
    severity: "High",
    docsUrl: "https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary",
  },
  {
    category: "TypeScript",
    guideline: "Type component props",
    description: "Define prop types for components",
    do: "interface Props { } or type Props = { }",
    dont: "any or untyped props",
    codeGood: "interface ButtonProps { variant: 'primary' | 'secondary'; onClick: () => void; }",
    codeBad: "function Button(props: any) { }",
    severity: "High",
    docsUrl: "https://react.dev/learn/typescript",
  },
];

// Knowledge Base - Flutter Guidelines
// Data converted from stacks/flutter.csv

import type { StackGuideline } from "./types";

export const flutterGuidelines: StackGuideline[] = [
  {
    category: "Widgets",
    guideline: "Prefer StatelessWidget when possible",
    description: "Use StatelessWidget for UI that depends only on its configuration and does not change over time",
    do: "Use StatelessWidget for static or purely declarative UI",
    dont: "Use StatefulWidget when no mutable state is needed",
    codeGood: "class Greeting extends StatelessWidget {\n  final String name;\n  const Greeting({required this.name});\n  @override Widget build(ctx) => Text('Hello, $name');\n}",
    codeBad: "class Greeting extends StatefulWidget { ... } // No state needed",
    severity: "Medium",
    docsUrl: "https://docs.flutter.dev/development/ui/widgets-intro",
  },
  {
    category: "Widgets",
    guideline: "Keep build methods small and focused",
    description: "Extract sub-trees into separate widget classes or methods to improve readability and rebuild performance",
    do: "Split complex widgets into smaller widget classes",
    dont: "Put entire UI in a single build method",
    codeGood: "class UserProfile extends StatelessWidget {\n  @override Widget build(ctx) => Column(children: [UserAvatar(), UserInfo(), UserActions()]);\n}",
    codeBad: "Widget build(ctx) { return Column(children: [ /* 200 lines of nested widgets */ ]); }",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/perf/best-practices",
  },
  {
    category: "State",
    guideline: "Use Provider or Riverpod for state management",
    description: "Use a proven state management solution instead of ad-hoc approaches for shared state",
    do: "Use Riverpod or Provider for dependency injection and state management",
    dont: "Pass state down through many constructor parameters",
    codeGood: "final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) => CounterNotifier());",
    codeBad: "MyPage(counter: counter, onIncrement: inc, onDecrement: dec, onReset: reset)",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/data-and-backend/state-mgmt/options",
  },
  {
    category: "State",
    guideline: "Keep state minimal in StatefulWidget",
    description: "Only store state that actually changes and requires a rebuild. Derive other values in build()",
    do: "Store only mutable data in State, compute derived values in build",
    dont: "Store computed or derived values in state",
    codeGood: "int _count = 0;\n@override Widget build(ctx) { final isEven = _count % 2 == 0; ... }",
    codeBad: "int _count = 0;\nbool _isEven = true; // Redundant, derived from _count",
    severity: "Medium",
    docsUrl: "https://docs.flutter.dev/development/ui/interactive",
  },
  {
    category: "Layout",
    guideline: "Use Row, Column, and Stack for layout",
    description: "Flutter uses a composition model with Row, Column, Stack, and Flex for layout",
    do: "Compose layouts with Row, Column, Expanded, and Flexible",
    dont: "Use nested Container widgets for layout purposes",
    codeGood: "Row(children: [Expanded(child: Text('Name')), SizedBox(width: 8), ElevatedButton(onPressed: ..., child: Text('Save'))])",
    codeBad: "Container(child: Container(margin: ..., child: Container(padding: ..., child: ...)))",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/development/ui/layout",
  },
  {
    category: "Lists",
    guideline: "Use ListView.builder for long lists",
    description: "ListView.builder creates items lazily as they scroll into view, important for performance with large lists",
    do: "Use ListView.builder or ListView.separated for dynamic lists",
    dont: "Use ListView with children list for large data sets",
    codeGood: "ListView.builder(itemCount: items.length, itemBuilder: (ctx, i) => ListTile(title: Text(items[i].name)))",
    codeBad: "ListView(children: items.map((i) => ListTile(title: Text(i.name))).toList()) // All built upfront",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/cookbook/lists/long-lists",
  },
  {
    category: "Navigation",
    guideline: "Use GoRouter for declarative routing",
    description: "GoRouter provides a declarative routing API with deep linking, guards, and nested routes",
    do: "Define routes with GoRouter and use context.go() or context.push()",
    dont: "Use Navigator.push with MaterialPageRoute for complex navigation",
    codeGood: "GoRouter(routes: [GoRoute(path: '/user/:id', builder: (ctx, state) => UserScreen(id: state.pathParameters['id']!))])",
    codeBad: "Navigator.push(context, MaterialPageRoute(builder: (ctx) => UserScreen(id: id)))",
    severity: "Medium",
    docsUrl: "https://pub.dev/packages/go_router",
  },
  {
    category: "Async",
    guideline: "Use FutureBuilder and StreamBuilder",
    description: "FutureBuilder and StreamBuilder properly handle async state (loading, error, data) in the widget tree",
    do: "Use FutureBuilder/StreamBuilder with proper snapshot handling",
    dont: "Use setState in async callbacks without checking mounted",
    codeGood: "FutureBuilder<User>(future: fetchUser(), builder: (ctx, snap) {\n  if (snap.hasError) return ErrorWidget(snap.error!);\n  if (!snap.hasData) return CircularProgressIndicator();\n  return Text(snap.data!.name);\n})",
    codeBad: "initState() { fetchUser().then((u) { setState(() { user = u; }); }); } // May call setState after dispose",
    severity: "High",
    docsUrl: "https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html",
  },
  {
    category: "Theming",
    guideline: "Use ThemeData for consistent styling",
    description: "Define colors, typography, and component themes centrally in ThemeData",
    do: "Configure ThemeData in MaterialApp and access via Theme.of(context)",
    dont: "Hardcode colors and text styles throughout the app",
    codeGood: "MaterialApp(theme: ThemeData(colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue), useMaterial3: true))",
    codeBad: "Text('Title', style: TextStyle(fontSize: 24, color: Color(0xFF1976D2))) // Hardcoded everywhere",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/cookbook/design/themes",
  },
  {
    category: "Animation",
    guideline: "Use implicit animations for simple transitions",
    description: "AnimatedContainer, AnimatedOpacity, and other implicit animation widgets handle transitions automatically",
    do: "Use AnimatedContainer, AnimatedOpacity for simple property changes",
    dont: "Use AnimationController for simple property transitions",
    codeGood: "AnimatedContainer(duration: Duration(milliseconds: 300), width: isExpanded ? 200 : 100, color: isActive ? Colors.blue : Colors.grey)",
    codeBad: "AnimationController + Tween + AnimatedBuilder for a simple size change",
    severity: "Medium",
    docsUrl: "https://docs.flutter.dev/development/ui/animations/implicit-animations",
  },
  {
    category: "Performance",
    guideline: "Use const constructors",
    description: "Const constructors allow Flutter to skip rebuilding widgets that have not changed",
    do: "Mark widget constructors as const and use const when instantiating",
    dont: "Omit const for widgets that could be compile-time constants",
    codeGood: "const SizedBox(height: 16), const Icon(Icons.check), const Text('Static')",
    codeBad: "SizedBox(height: 16), Icon(Icons.check), Text('Static') // Rebuilt every time",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/perf/best-practices#use-const-widgets-where-possible",
  },
  {
    category: "Performance",
    guideline: "Avoid rebuilding expensive sub-trees",
    description: "Push state changes down the tree so that only widgets that need to update are rebuilt",
    do: "Extract stateful parts into separate widgets to minimize rebuild scope",
    dont: "Call setState at a high level causing the entire sub-tree to rebuild",
    codeGood: "class Counter extends StatefulWidget { ... } // Only this widget rebuilds",
    codeBad: "Calling setState in a top-level Scaffold widget to update a single counter text",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/perf/best-practices",
  },
  {
    category: "Accessibility",
    guideline: "Use Semantics widget for accessibility",
    description: "Provide semantic information for screen readers using the Semantics widget and semantic properties",
    do: "Add Semantics wrapper with label, hint, and role for custom widgets",
    dont: "Rely solely on visual appearance without semantic information",
    codeGood: "Semantics(label: 'Play video', button: true, child: GestureDetector(onTap: play, child: PlayIcon()))",
    codeBad: "GestureDetector(onTap: play, child: PlayIcon()) // No accessibility info",
    severity: "High",
    docsUrl: "https://docs.flutter.dev/development/accessibility-and-localization/accessibility",
  },
  {
    category: "Accessibility",
    guideline: "Ensure sufficient touch targets",
    description: "Interactive elements should have a minimum touch target size of 48x48 logical pixels",
    do: "Use Material widgets that have built-in minimum sizes or wrap with SizedBox",
    dont: "Create tiny tap targets without adequate sizing",
    codeGood: "SizedBox(width: 48, height: 48, child: IconButton(icon: Icon(Icons.close), onPressed: onClose))",
    codeBad: "GestureDetector(onTap: onClose, child: Icon(Icons.close, size: 16)) // Too small",
    severity: "Medium",
    docsUrl: "https://docs.flutter.dev/development/accessibility-and-localization/accessibility",
  },
];
